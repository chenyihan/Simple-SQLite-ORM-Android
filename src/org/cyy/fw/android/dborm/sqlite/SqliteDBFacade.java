package org.cyy.fw.android.dborm.sqlite;

import java.util.Map;

import org.cyy.fw.android.dborm.AnnotationORMapper;
import org.cyy.fw.android.dborm.DBAccessException;
import org.cyy.fw.android.dborm.ORMapper;
import org.cyy.fw.android.dborm.OneToAny;
import org.cyy.fw.android.dborm.SQLObject;
import org.cyy.fw.android.dborm.UUIDGenerator;
import org.cyy.fw.android.dborm.UniqueIDGenerator;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDatabase.CursorFactory;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

/**
 * 
 * SQLite DB Accessed Facade, called by application code.<br>
 * The facade provides several interface for DB accessing with a OO style by
 * simple O-R mapping, such as {@link #query(Class, Object)},
 * {@link #insert(Object)}, {@link #update(Object, Object)},
 * {@link #delete(Class, Object)} and so on. User can operate the DB table the
 * same as simple java object, without caring about any SQL details, but of
 * course, this is a ideal scenario, you still have to turn to SQLs in some
 * complex scenario. User also can build SQLs by provided API, such as
 * {@link #buildDeleteSql(Class, Object)}, {@link #buildInsertSql(Object[])},
 * {@link #buildUpdateSql(Object, Object)} and so on, and execute this SQLs by
 * calling {@link #execSQL(SQLObject[])} passing the returned {@link SQLObject}
 * parameter.<br>
 * This framework define the O-R mapping by java annotation:<br>
 * <p>
 * <li>Here are four annotation that fulfill mapping tasks:
 * {@link org.cyy.fw.android.dborm.Table},
 * {@link org.cyy.fw.android.dborm.Column},
 * {@link org.cyy.fw.android.dborm.PrimaryKey},
 * {@link org.cyy.fw.android.dborm.OneToAny}
 * <p>
 * {@link org.cyy.fw.android.dborm.Table} is a Class annotation, it mappings the
 * DB table and POJO, the name attribute is used to specified the table name,
 * the framework will use the Class simple name for table name if this name
 * attribute hasn't a non-null value.
 * 
 * <pre>
 * &#064;Table(name = &quot;t1&quot;)
 * public static class TestTable
 * {
 * }
 * The above class will mapping to the table named 't1'.
 * </pre>
 * 
 * The framework allow a java class mappings several tables, the name attribute
 * is a array type.
 * 
 * <pre>
 * &#064;Table(name = { &quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot; })
 * public static class TestTable {
 * 	// ...
 * }
 * </pre>
 * 
 * By the above code fragment, TestTable mappings tables named 't1' 't2' 't3',
 * you must specified table name when accessing DB in this case, otherwise, the
 * framework will access the first table(it is 't1' in this example), the most
 * APIs have a tablename parameter, such as
 * {@link #query(Class, Object, String)}, the last parameter is the tablename
 * parameter.<br>
 * {@link org.cyy.fw.android.dborm.Column} is the annotation used to mapping the
 * class attributes with table columns, the name attribute of this annotation
 * specifies the column name, the attribute name will be the column name if this
 * attribute hasn't a non-null value. It's the sample as follow:
 * 
 * <pre>
 * &#064;Table(name = &quot;t1&quot;)
 * public static class TestTable {
 * 	&#064;PrimaryKey(columnName = &quot;id1&quot;)
 * 	private Integer id;
 * 	&#064;Column(name = &quot;name1&quot;)
 * 	private String name;
 * 	private String address;
 * 	&#064;Column
 * 	private Double money;
 * 
 * 	public Integer getId() {
 * 		return id;
 * 	}
 * 
 * 	public void setId(Integer id) {
 * 		this.id = id;
 * 	}
 * 
 * 	public String getName() {
 * 		return name;
 * 	}
 * 
 * 	public void setName(String name) {
 * 		this.name = name;
 * 	}
 * 
 * 	public String getAddress() {
 * 		return address;
 * 	}
 * 
 * 	public void setAddress(String address) {
 * 		this.address = address;
 * 	}
 * 
 * 	public Double getMoney() {
 * 		return money;
 * 	}
 * 
 * 	public void setMoney(Double money) {
 * 		this.money = money;
 * 	}
 * 
 * }
 * </pre>
 * 
 * {@link org.cyy.fw.android.dborm.PrimaryKey} is similar with
 * {@link org.cyy.fw.android.dborm.Column}, it's the primary key annotation, the
 * primary key will be auto-incremented and generated by DB if the sequence
 * attribute is set true, or the primary key value will be generated by the
 * framework if the genUIDBySelf attribute is set true. The table will haven't
 * primary key if any attribute of the mapped class defined with this
 * annotation.<br>
 * {@link org.cyy.fw.android.dborm.OneToAny} is used to specify one-to-one or
 * one-to-many relation of two tables, acts on the complex attribute of mapped
 * class, it has three attribute:<br>
 * target: The relation target full class name, if class attribute's type is a
 * POJO class or generic List(must be generic and so sorry for just supporting
 * List so far), this annotation attribute can be null, because the framework
 * can check the target in this case. <br>
 * sourceField: relation source attribute, the framework will use primary key if
 * the value is null<br>
 * targetField: relation target attribute, it will appear in the left join part
 * while building SQLs<br>
 * 
 * <pre>
 * &#064;Table(name = &quot;t1&quot;)
 * public static class TestTable {
 * 	&#064;PrimaryKey(columnName = &quot;id1&quot;, sequence = true)
 * 	private Integer id;
 * 	&#064;OneToAny(targetField = &quot;bid&quot;)
 * 	private T2 brother;
 * 	&#064;OneToAny(targetField = &quot;pid&quot;)
 * 	private List&lt;Child&gt; childList;
 * 
 * 	public T2 getBrother() {
 * 		return brother;
 * 	}
 * 
 * 	public void setBrother(T2 brother) {
 * 		this.brother = brother;
 * 	}
 * 
 * 	public Integer getId() {
 * 		return id;
 * 	}
 * 
 * 	public void setId(Integer id) {
 * 		this.id = id;
 * 	}
 * 
 * 	public List&lt;Child&gt; getChildList() {
 * 		return childList;
 * 	}
 * 
 * 	public void setChildList(List&lt;Child&gt; childList) {
 * 		this.childList = childList;
 * 	}
 * 
 * }
 * 
 * &#064;Table(name = &quot;c1&quot;)
 * public static class Child {
 * 	&#064;PrimaryKey(columnName = &quot;id1&quot;, sequence = true)
 * 	private Integer id;
 * 	&#064;Column
 * 	private Integer pid;
 * 
 * 	&#064;Column(name = &quot;name&quot;)
 * 	private String childName;
 * 
 * 	public Integer getId() {
 * 		return id;
 * 	}
 * 
 * 	public void setId(Integer id) {
 * 		this.id = id;
 * 	}
 * 
 * 	public Integer getPid() {
 * 		return pid;
 * 	}
 * 
 * 	public void setPid(Integer pid) {
 * 		this.pid = pid;
 * 	}
 * 
 * 	public String getChildName() {
 * 		return childName;
 * 	}
 * 
 * 	public void setChildName(String childName) {
 * 		this.childName = childName;
 * 	}
 * 
 * }
 * 
 * &#064;Table
 * public static class T2 {
 * 	&#064;PrimaryKey(columnName = &quot;id2&quot;)
 * 	private Integer id;
 * 	&#064;Column
 * 	private String n1;
 * 	&#064;Column
 * 	private Integer bid;
 * 
 * 	public Integer getId() {
 * 		return id;
 * 	}
 * 
 * 	public void setId(Integer id) {
 * 		this.id = id;
 * 	}
 * 
 * 	public String getN1() {
 * 		return n1;
 * 	}
 * 
 * 	public void setN1(String n1) {
 * 		this.n1 = n1;
 * 	}
 * 
 * 	public Integer getBid() {
 * 		return bid;
 * 	}
 * 
 * 	public void setBid(Integer bid) {
 * 		this.bid = bid;
 * 	}
 * 
 * }
 * </pre>
 * 
 * The above TestTable class defines two relation attribute: brother and
 * childList relate T2 class and Child class separately, and will generate the
 * SQL segment
 * <code>"left join T2 on T2.bid = t1.id1 left join c1 on c1.pid = t1.id1"</code>
 * while building SQLs<br>
 * The {@link org.cyy.fw.android.dborm.AnnotationORMapper} class will fulfill
 * the mapping logic.
 * <p>
 * <font size="2" color="red"><b>Note: The POJO class must comply with the beans
 * specifications:<br>
 * (1).The mapped attribute must have pair of setter and getter, and the name of
 * getter and setter must comply with java bean specifications, you can generate
 * them by eclipse-&gt;Source-&gt;Generate Getters and Setters.<br>
 * (2).If the attribute is a primary type, you'd better use the wrapper class of
 * the primary type, such as Integer, Float and so on. </b></font> <br>
 * User can implement the {@link org.cyy.fw.android.dborm.ORMapper} interface to
 * customize mapping logic and injection it by calling
 * {@link #setOrMapper(ORMapper)}
 * <p>
 * This facade class is a abstract class, user need to extend it and do a few
 * things more:<br>
 * (1).Name the DB, android will create the specified DB file in the databases
 * folder of the application<br>
 * (2).Implement the {@link #configureORMClasses()} method, configure all mapped
 * POJO classes, the DB will create tables accordinging to this configured
 * classes
 * 
 * <br>
 * 
 * @author cyy
 * @version [V1.0, 2012-11-5]
 * 
 * 
 */
public abstract class SqliteDBFacade extends SQLiteOpenHelper {

	private static final String TAG = "SqliteDBFacade";

	private UniqueIDGenerator mIDGenerator;

	private ORMapper orMapper;

	private ValueConvertor valueConvertor;

	/**
	 * 
	 * @param context
	 *            application context
	 * @param name
	 *            DB name
	 * @param version
	 *            DB version
	 */
	public SqliteDBFacade(Context context, String name, int version) {
		this(context, name, null, version);
	}

	public SqliteDBFacade(Context context, String name, CursorFactory factory,
			int version) {
		super(context, name, factory, version);
	}

	/**
	 * 
	 * build create table SQL<BR>
	 * 
	 * @param clazz
	 *            POJO class
	 * @param tableName
	 *            table name
	 * @return SQL object
	 */
	public SQLObject buildCreateSql(Class<?> clazz, String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		String sql = sqlBuild.buildCreateTableSql(clazz, tableName);
		SQLObject sqlObj = new SQLObject(sql, null);
		return sqlObj;
	}

	/**
	 * 
	 * Generate delete SQL accordinging by condition described by POJO.
	 * @param clazz
	 *            POJO class, if the condition parameter is a non-null value,
	 *            this parameter is allowed to be null, otherwise isn't.
	 * @param condition
	 *            Delete condition, described by POJO, for example, a condition
	 *            object has two attributes a=1 and b="b1", it will suggest the
	 *            framework to build a SQL "where part a=1 and b = 'b'" for the
	 *            final SQL. The null value attribute will be ignored while
	 *            building SQL where part, so the POJO's primary type attribute
	 *            is suggested to use the wrapper class of the specified primary
	 *            type instead, because all primary types have a default value,
	 *            if a POJO has a int type attribute named intAttr, its value
	 *            will be 0 if it hasn't been set any value, so the framework
	 *            will append a "intAttr = 0" SQL segment for the final SQL. The
	 *            condition parameter can be a null value, if i's null, the
	 *            framework will query all data rows of the specified table, but
	 *            keep in mind that, the clazz parameter of this method must be
	 *            a non-null value if the condition parameter is null, otherwise
	 *            the framework will have no idea what table you want to query.
	 * 
	 * @return Delete SQL object includes SQL and binded parameter
	 */
	public SQLObject buildDeleteSql(Class<?> clazz, Object condition) {
		return buildDeleteSql(clazz, condition, null);
	}

	/**
	 * 
	 * Generate delete SQL of the specified table according by condition
	 * described by POJO.
	 * @param clazz
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param condition
	 *            As same as condition parameter of
	 *            {@link #buildDeleteSql(Class, Object)}
	 * @param tableName
	 *            The table's name
	 * 
	 * @return Delete SQL object includes SQL and binded parameter
	 */
	public SQLObject buildDeleteSql(Class<?> clazz, Object condition,
			String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildDeleteSql(condition, clazz, getValueConvertor(),
				tableName);
	}

	/**
	 * 
	 * Generate the insert SQL<BR>
	 * 
	 * @param entities
	 *            The POJOs to be inserted
	 * @return Insert SQL object includes SQL and binded parameter
	 */
	public SQLObject[] buildInsertSql(Object[] entities) {
		return buildInsertSql(entities, null);
	}

	/**
	 * 
	 * Generate the insert SQL for some specified tables
	 * 
	 * @param entities
	 *            The POJOs to be inserted
	 * @param tableMap
	 *            The table name map, the key is the POJO class, the value is
	 *            the table name
	 * @return Insert SQL object includes SQL and binded parameter
	 */
	public SQLObject[] buildInsertSql(Object[] entities,
			Map<Class<?>, String> tableMap) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildInsertSql(entities, getValueConvertor(), tableMap,
				getUIDGenerator());
	}

	/**
	 * 
	 * Generate the insert SQL for some specified tables<BR>
	 * It will process relationship.
	 * 
	 * @param objects
	 *            The POJOs to be inserted
	 * @param childrenClasses
	 *            The parameter is used to check whether need to generate the
	 *            inserted SQL for the target relation POJO, if this parameter
	 *            is null, all the attributes which have the {@link OneToAny}
	 *            annotation will generate a insert SQL for the target POJO.
	 * @param tableMap
	 *            The table name map, the key is the POJO class, the value is
	 *            the table name
	 * 
	 * @return Insert SQL object includes SQL and binded parameter
	 */
	public SQLObject[] buildCascadeInsertSqls(Object[] objects,
			Class<?>[] childrenClasses, Map<Class<?>, String> tableMap) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildCascadeInsertSqls(objects, childrenClasses,
				getValueConvertor(), tableMap, getUIDGenerator());
	}

	/**
	 * 
	 * Generate update SQL according by condition described by POJO.
	 * 
	 * @param newValue
	 *            The updated value, described by POJO, if it has a attribute
	 *            named a has a non-value 1 and a attribute named b has a null
	 *            value, it will generate the SQL segment set a = 1 for the
	 *            final SQL and the attribute will be ignored for SQL.
	 * @param condition
	 *            As same as condition parameter of
	 *            {@link #buildDeleteSql(Class, Object)}
	 * @return Update SQL
	 */
	public SQLObject buildUpdateSql(Object newValue, Object condition) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSql(newValue, condition,
				getValueConvertor(), null, null);
	}

	/**
	 * 
	 * Generate update SQL of the specified table according by condition
	 * described by POJO.
	 * 
	 * @param newValue
	 *            The updated value, described by POJO, if it has a attribute
	 *            named a has a non-value 1 and a attribute named b has a null
	 *            value, it will generate the SQL segment set a = 1 for the
	 *            final SQL and the attribute will be ignored for SQL.
	 * @param condition
	 *            As same as condition parameter of
	 *            {@link #buildDeleteSql(Class, Object)}
	 * @param tableName
	 *            The table's name
	 * @return Update SQL
	 */
	public SQLObject buildUpdateSql(Object newValue, Object condition,
			String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSql(newValue, condition,
				getValueConvertor(), null, tableName);
	}

	/**
	 * 
	 * Generate update SQL of the specified table according by condition
	 * described by POJO.
	 * 
	 * 
	 * @param newValue
	 *            The updated value, described by POJO, if it has a attribute
	 *            named a has a non-value 1 and a attribute named b has a null
	 *            value, it will generate the SQL segment set a = 1 for the
	 *            final SQL, if b is included in notIgnoreNullFields parameter,
	 *            the framework will generate "a = null" SQL segment for final
	 *            SQL, otherwise the b attribute will be ignored
	 * 
	 * @param condition
	 *            As same as condition parameter of
	 *            {@link #buildDeleteSql(Class, Object)}
	 * 
	 * @param notIgnoreNullFields
	 *            Including fields that don't ignore null value, see the
	 *            newValue parameter for detail
	 * 
	 * @return Update SQL
	 */
	public SQLObject buildUpdateSql(Object newValue, Object condition,
			String[] notIgnoreNullFields) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSql(newValue, condition,
				getValueConvertor(), notIgnoreNullFields, null);
	}

	/**
	 * 
	 * Generate update SQL of the specified table according by condition
	 * described by POJO.
	 * 
	 * @param newValue
	 *            The updated value, described by POJO, if it has a attribute
	 *            named a has a non-value 1 and a attribute named b has a null
	 *            value, it will generate the SQL segment set a = 1 for the
	 *            final SQL, if b is included in notIgnoreNullFields parameter,
	 *            the framework will generate "a = null" SQL segment for final
	 *            SQL, otherwise the b attribute will be ignored
	 * @param condition
	 *            As same as condition parameter of
	 *            {@link #buildDeleteSql(Class, Object)}
	 * @param notIgnoreNullFields
	 *            Including fields that don't ignore null value, see the
	 *            newValue parameter for detail
	 * @param tableName
	 *            The table's name
	 * 
	 * @return Update SQL
	 */
	public SQLObject buildUpdateSql(Object newValue, Object condition,
			String[] notIgnoreNullFields, String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSql(newValue, condition,
				getValueConvertor(), notIgnoreNullFields, tableName);
	}

	/**
	 * 
	 * Generate update SQLs of the specified table according by conditions
	 * described by POJOs.
	 * 
	 * @param newValue
	 *            As same as {@link #buildUpdateSql(Object, Object)}
	 * @param conditions
	 *            As same as {@link #buildUpdateSql(Object, Object)}, including
	 *            several condition
	 * @return Update SQLs
	 */
	public SQLObject[] buildUpdateSqls(Object newValue, Object[] conditions) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSqls(newValue, conditions,
				getValueConvertor(), null, null);
	}

	/**
	 * 
	 * @see #buildUpdateSqls(Object, Object[])
	 */
	public SQLObject[] buildUpdateSqls(Object newValue, Object[] conditions,
			String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSqls(newValue, conditions,
				getValueConvertor(), null, tableName);
	}

	/**
	 * 
	 * @see #buildUpdateSql(Object, Object, String[])
	 */
	public SQLObject[] buildUpdateSqls(Object newValue, Object[] conditions,
			String[] notIgnoreNullFields) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSqls(newValue, conditions,
				getValueConvertor(), notIgnoreNullFields, null);
	}

	/**
	 * 
	 * @see #buildUpdateSql(Object, Object, String[], String)
	 */
	public SQLObject[] buildUpdateSqls(Object newValue, Object[] conditions,
			String[] notIgnoreNullFields, String tableName) {
		SQLBuilder sqlBuild = new SQLBuilder(getOrMapper());
		return sqlBuild.buildUpdateSqls(newValue, conditions,
				getValueConvertor(), notIgnoreNullFields, tableName);
	}

	/**
	 * 
	 * Close database<BR>
	 * 
	 */
	public void closeDatabase() {
		this.close();
	}

	/**
	 * 
	 * Delete table's data according by condition
	 * @param clazz
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param condition
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * 
	 * @return Deleted rows
	 */
	public int delete(Class<?> clazz, Object condition) {
		return delete(clazz, condition, (String) null);
	}

	/**
	 * 
	 * Delete table's data according by condition
	 * @param clazz
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param condition
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param parameter
	 *            Aid parameter, such as extra where part and so on
	 * 
	 * @return Deleted rows
	 */
	public int delete(Class<?> clazz, Object condition,
			QueryAidParameter parameter) {
		return delete(clazz, condition, parameter, null);
	}

	/**
	 * 
	 * @see #delete(Class, Object, QueryAidParameter)
	 */
	public int delete(Class<?> clazz, Object condition,
			QueryAidParameter parameter, String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.delete(clazz, condition, parameter, tableName);
	}

	/**
	 * 
	 * @see #delete(Class, Object)
	 */
	public int delete(Class<?> clazz, Object condition, String tableName) {
		return delete(clazz, condition, null, tableName);
	}

	/**
	 * 
	 * Delete data according by primary key value
	 * 
	 * @param clazz
	 *            POJO class
	 * @param pk
	 *            Primary key value
	 * @return Deleted rows
	 */
	public int deleteByPk(Class<?> clazz, Object pk) {
		return deleteByPk(clazz, pk, null);
	}

	/**
	 * 
	 * @see #deleteByPk(Class, Object)
	 */
	public int deleteByPk(Class<?> clazz, Object pk, String tableName) {
		if (clazz == null || pk == null) {
			throw new IllegalArgumentException("paramter error.");
		}
		return deleteByPks(clazz, new Object[] { pk }, tableName);
	}

	/**
	 * 
	 * Batch deletion according primary keys for specified table
	 * 
	 * @param clazz
	 *            POJO class
	 * @param pks
	 *            Primary key values
	 * @return Deleted rows
	 */
	public int deleteByPks(final Class<?> clazz, Object[] pks) {
		return deleteByPks(clazz, pks, null);
	}

	/**
	 * 
	 * @see #deleteByPks(Class, Object[])
	 */
	public int deleteByPks(Class<?> clazz, Object[] pks, String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.deleteByPks(clazz, pks, tableName);
	}

	/**
	 * 
	 * Batch SQLs execution, may deal with some insertion, update, deletion in a
	 * single transaction, you should call the buildXXXSQL method for SQLObject
	 * parameter before call this method
	 * 
	 * @param execSqls
	 *            SQLs
	 */
	public void execSQL(final SQLObject[] execSqls) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		dbDelegator.execSQL(execSqls);
	}

	/**
	 * 
	 * Batch SQLs execution of a specified DB instance, may deal with some
	 * insertion, update, deletion in a single transaction, you should call the
	 * buildXXXSQL method for SQLObject parameter before call this method
	 * 
	 * @param execSqls
	 *            SQLs
	 * @param db
	 *            DB instance
	 */
	public void execSQL(final SQLObject[] execSqls, SQLiteDatabase db) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		dbDelegator.setDatabase(db);
		dbDelegator.execSQL(execSqls);
	}

	/**
	 * 
	 * Single SQL execution.
	 * 
	 * @see #execSQL(SQLObject[])
	 * 
	 * @param sql
	 *            SQL
	 */
	public void execSQL(String sql) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		dbDelegator.execSQL(sql);
	}

	/**
	 * 
	 * Insert a POJO into the DB<BR>
	 * 
	 * @param object
	 *            POJO
	 * 
	 * @return The row id after inserted into the DB table
	 */
	public long insert(Object object) {
		return insert(object, null);
	}

	/**
	 * 
	 * @see #insert(Object)
	 */
	public long insert(Object object, String table) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.insert(object, table);
	}

	/**
	 * 
	 * @see #insert(Object)
	 */
	public long[] insert(Object[] objects) {
		return insert(objects, (Map<Class<?>, String>) null);
	}

	/**
	 * 
	 * @see #insert(Object[])
	 */
	public long[] insert(Object[] objects, Map<Class<?>, String> tableMap) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.insert(objects, tableMap);
	}

	/**
	 * 
	 * Insert a POJO into the DB,also will insert relation table including in
	 * parameter childrenClasses <BR>
	 * 
	 * @param objects
	 *            POJO
	 * @param childrenClasses
	 *            As same as
	 *            {@link #buildCascadeInsertSqls(Object[], Class[], Map)}
	 */
	public void insertCascade(Object[] objects, Class<?>[] childrenClasses) {
		insertCascade(objects, childrenClasses, null);
	}

	/**
	 * 
	 * @see #insertCascade(Object[], Class[])
	 */
	public void insertCascade(Object[] objects, Class<?>[] childrenClasses,
			Map<Class<?>, String> tableMap) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		dbDelegator.insertCascade(objects, childrenClasses, tableMap);
	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		Log.i("db", "create database");
		SqliteDBDelegator dbDelegator = createDbDelegator();
		dbDelegator.setDatabase(db);
		Class<?>[] classes = this.configureORMClasses();
		if (classes == null || classes.length == 0) {
			return;
		}
		dbDelegator.createTables(classes);
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		Log.i(TAG, "update database from version:" + oldVersion + "to version:"
				+ newVersion);
		if (this instanceof DBAutoUpgradeAdapter) {
			DBAutoUpgradeAdapter upgrader = (DBAutoUpgradeAdapter) this;
			upgrader.upgradeTables(db);
			return;
		}
	}

	public void upgradeTables(SQLiteDatabase db) {
		Log.i(TAG, "upgradeTables");
		Class<?>[] classes = this.configureORMClasses();
		SqliteDBDelegator dbDelegator = createDbDelegator();
		dbDelegator.setDatabase(db);
		dbDelegator.upgradeTables(classes);
	}

	/**
	 * 
	 * Query data according by the condition <BR>
	 * @param clazz
	 *            POJO class
	 * @param condition
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param fields
	 *            Queried columns, will query all columns if this parameter is
	 *            null
	 * @param parameterObject
	 *            Aid Query parameter, such as group by, order by, having, limit
	 *            and so one
	 * 
	 * @param <T>
	 * @return The query result
	 * @see #query(Class, Object)
	 */
	public <T> T[] query(Class<T> clazz, T condition, String[] fields,
			final QueryAidParameter parameterObject) {
		return query(clazz, condition, fields, parameterObject, null);
	}

	/**
	 * 
	 * @see #query(Class, Object, String[], QueryAidParameter)
	 */
	public <T> T[] query(Class<T> clazz, T condition, String[] fields,
			final QueryAidParameter parameterObject, String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.query(clazz, condition, fields, parameterObject,
				tableName);
	}

	/**
	 * 
	 * @see #query(Class, Object, String[], QueryAidParameter)
	 */
	public <T> T[] query(Class<T> clazz, T condition) {
		return query(clazz, condition, (String[]) null);
	}

	/**
	 * 
	 * @see #query(Class, Object, String[], QueryAidParameter)
	 */
	public <T> T[] query(Class<T> clazz, T condition, String tableName) {
		return query(clazz, condition, null, tableName);
	}

	/**
	 * 
	 * @see #query(Class, Object, String[], QueryAidParameter)
	 */
	public <T> T[] query(Class<T> clazz, T condition, String[] fields) {
		return query(clazz, condition, fields, (String) null);
	}

	/**
	 * 
	 * @see #query(Class, Object, String[], QueryAidParameter)
	 */
	public <T> T[] query(Class<T> clazz, T condition, String[] fields,
			String tableName) {
		return query(clazz, condition, fields, null, tableName);
	}

	/**
	 * 
	 * Query data according by condition, will query relation table<BR>
	 * The childrenPaths parameter is used to specify the queried relation
	 * tables. It put some relation paths, the path's rule is as follow:
	 * Starting from the root class, according to the related attribute of the
	 * root class is the root class association class associated attributes, in
	 * turn recursively, put these associated attributes according to the order.
	 * A mosaic, for example: there are three classes of T1, T2, T3, T1 through
	 * the attribute childList1 associated with T2, T2 by childList2 associated
	 * T3 (Association through com.huawei.softclient.common.database.OneToAny)
	 * annotation specified, if while searching for T1 records need also
	 * associated T2 and T3 records, related path should be
	 * <code>childList1.childList2</code><br>
	 * It's the sample code as follow:
	 * 
	 * <pre>
	 * tables = facade.queryByConditionCascade(T1.class, new String[] {
	 * 		&quot;childList.childList2&quot;, &quot;brother1.brother2.brother3&quot; }, condition);
	 * </pre>
	 * 
	 * Node: the method only support some simple scenario, you should turn to
	 * {@link #rawQuery(String, String[])} in the complex scenario
	 * 
	 * @param clazz
	 *            POJO class
	 * @param condition
	 *            As same as {@link #buildDeleteSql(Class, Object)}
	 * @param childrenPaths
	 *            Relation paths, It will only query the data of main table if
	 *            this parameter is null.
	 * @return Query result
	 * @param <T>
	 */
	public <T> T[] queryCascadeByCondition(Class<T> clazz, T condition,
			String[] childrenPaths) {
		return queryCascadeByCondition(clazz, condition, childrenPaths, null);
	}

	/**
	 * 
	 * @see #queryCascadeByCondition(Class, Object, String[])
	 */
	public <T> T[] queryCascadeByCondition(Class<T> clazz, T condition,
			String[] childrenPaths, Map<Class<?>, String> tableMap) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.queryCascadeByCondition(clazz, condition,
				childrenPaths, tableMap);
	}

	/**
	 * 
	 * Query data according by primary key value<BR>
	 * 
	 * @param clazz
	 *            POJO class
	 * @param pk
	 *            Primary key value
	 * @param <T>
	 * @return Query result
	 */
	public <T> T queryByPk(Class<T> clazz, Object pk) {
		return queryByPk(clazz, pk, null);
	}

	/**
	 * 
	 * @see #queryByPk(Class, Object)
	 */
	public <T> T queryByPk(final Class<T> clazz, Object pk, String tableName) {

		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.queryByPk(clazz, pk, tableName);
	}

	/**
	 * 
	 * @see #queryByPk(Class, Object)
	 */
	public <T> T[] queryByPks(final Class<T> clazz, Object[] pks) {
		return queryByPks(clazz, pks, null);
	}

	/**
	 * 
	 * @see #queryByPk(Class, Object)
	 */
	public <T> T[] queryByPks(final Class<T> clazz, Object[] pks,
			String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.queryByPks(clazz, pks, tableName);
	}

	/**
	 * 
	 * Query data according by primary key values, will query relation table
	 * 
	 * @see #queryCascadeByCondition(Class, Object, String[])
	 */
	public <T> T[] queryCascadeByPks(final Class<T> clazz, Object[] pks,
			final String[] childrenPaths) {
		return queryCascadeByPks(clazz, pks, childrenPaths, null);
	}

	/**
	 * 
	 * @see #queryCascadeByPks(Class, Object[], String[])
	 */
	public <T> T[] queryCascadeByPks(final Class<T> clazz, Object[] pks,
			final String[] childrenPaths, Map<Class<?>, String> tableMap) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.queryCascadeByPks(clazz, pks, childrenPaths,
				tableMap);
	}

	/**
	 * 
	 * Execute complex SQL and return the cursor<BR>
	 * 
	 * @param sql
	 *            SQL
	 * @param selectionArgs
	 *            Binded parameter
	 * @return {@link Cursor}
	 */
	public Cursor rawQuery(String sql, String[] selectionArgs) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareReadableDbDelegator(dbDelegator);
		return dbDelegator.rawQuery(sql, selectionArgs);
	}

	public void setValueConvertor(ValueConvertor valueConvertor) {
		this.valueConvertor = valueConvertor;
	}

	/**
	 * 
	 * Update table data by condition described POJO<BR>
	 * 
	 * @param newValue
	 *            As same as {@link #buildUpdateSql(Object, Object)}
	 * @param condition
	 *            As same as {@link #buildUpdateSql(Object, Object)}
	 * 
	 * @return Updated rows
	 */
	public int update(Object newValue, Object condition) {
		return update(newValue, condition, (String[]) null);
	}

	/**
	 * 
	 * @see #update(Object, Object)
	 */
	public int update(Object newValue, Object condition, String tableName) {
		return update(newValue, condition, null, tableName);
	}

	/**
	 * 
	 * @see #update(Object, Object)
	 * @see #buildUpdateSql(Object, Object, String[])
	 */
	public int update(Object newValue, Object condition,
			String[] notIgnoreNullFields) {
		return update(newValue, condition, notIgnoreNullFields, null);
	}

	/**
	 * 
	 * @see #update(Object, Object)
	 * @see #buildUpdateSql(Object, Object, String[], String)
	 */
	public int update(Object newValue, Object condition,
			String[] notIgnoreNullFields, String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.update(newValue, condition, notIgnoreNullFields,
				tableName);
	}

	/**
	 * 
	 * Update data according by primary key, the POJO must declare a primary key
	 * annotation if want to call this method
	 * 
	 */
	public int updateByPk(Object value) {
		return updateByPk(value, null);
	}

	/**
	 * 
	 * @see {@link SqliteDBDelegator#updateByPk(Object)}
	 */
	public int updateByPk(Object value, String tableName) {
		if (value == null) {
			return 0;
		}
		return updateByPks(new Object[] { value }, null, tableName);
	}

	/**
	 * 
	 * @see {@link SqliteDBDelegator#updateByPk(Object)}
	 */
	public int updateByPks(Object[] values) {
		return updateByPks(values, (String[]) null);
	}

	/**
	 * 
	 * @see {@link SqliteDBDelegator#updateByPk(Object)}
	 */
	public int updateByPks(Object[] values, String tableName) {
		return updateByPks(values, null, tableName);
	}

	/**
	 * 
	 * @see {@link SqliteDBDelegator#updateByPk(Object)}
	 * @see #update(Object, Object, String[])
	 */
	public int updateByPks(Object[] values, String[] notIgnoreNullFields) {
		return updateByPks(values, notIgnoreNullFields, null);
	}

	/**
	 * 
	 * @see #updateByPks(Object[], String[])
	 */
	public int updateByPks(Object[] values, String[] notIgnoreNullFields,
			String tableName) {
		SqliteDBDelegator dbDelegator = createDbDelegator();
		prepareWritableDbDelegator(dbDelegator);
		return dbDelegator.updateByPks(values, notIgnoreNullFields, tableName);
	}

	/**
	 * 
	 * Set the O-R mapping tool.
	 * 
	 * @param orMapper
	 *            O-R mapping tool.
	 */
	protected void setOrMapper(ORMapper orMapper) {
		this.orMapper = orMapper;
	}

	protected void setUIDGenerator(UniqueIDGenerator gen) {
		mIDGenerator = gen;
	}

	/**
	 * 
	 * Configure all ORM classes of the application
	 * 
	 * @return All ORM classes of the application
	 */
	protected abstract Class<?>[] configureORMClasses();

	private SqliteDBDelegator createDbDelegator() {
		SqliteDBDelegator sqliteDBDelegator = new SqliteDBDelegator();
		sqliteDBDelegator.setOrMapper(getOrMapper());
		sqliteDBDelegator.setValueConvertor(getValueConvertor());
		sqliteDBDelegator.setUIDGenerator(getUIDGenerator());
		return sqliteDBDelegator;
	}

	private ORMapper getOrMapper() {
		if (this.orMapper == null) {
			this.orMapper = new AnnotationORMapper();
		}
		return orMapper;
	}

	private ValueConvertor getValueConvertor() {
		if (valueConvertor == null) {
			valueConvertor = new DefaultValueConvertor();
		}
		return valueConvertor;
	}

	private UniqueIDGenerator getUIDGenerator() {
		if (mIDGenerator == null) {
			mIDGenerator = new UUIDGenerator();
		}
		return mIDGenerator;
	}

	private void prepareReadableDbDelegator(SqliteDBDelegator dbDelegator) {
		SQLiteDatabase db = getReadableDatabase();
		if (db == null) {
			throw new DBAccessException("access db error.");
		}
		dbDelegator.setDatabase(db);
	}

	private void prepareWritableDbDelegator(SqliteDBDelegator dbDelegator) {
		SQLiteDatabase db = getWritableDatabase();
		if (db == null) {
			throw new DBAccessException("access db error.");
		}
		dbDelegator.setDatabase(db);
	}
}
